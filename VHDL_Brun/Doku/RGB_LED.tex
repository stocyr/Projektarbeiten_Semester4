
%% Dokumenteinstellungen %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[a4paper,oneside,12pt,ngerman]{scrartcl}

%% Deutsche Anpassungen %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}
\usepackage[ansinew]{inputenc}
\usepackage{lmodern} %Type1-Schriftart für nicht-englische Texte
\usepackage{booktabs}	% schönere tabellen

%% Packages für Grafiken & Abbildungen %%%%%%%%%%%%%%%%%%%%%%
\usepackage{graphicx} %%Zum Laden von Grafiken
%\usepackage{subfig} %%Teilabbildungen in einer Abbildung
%\usepackage{tikz} %%Vektorgrafiken aus LaTeX heraus erstellen


%% Packages für Formeln %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}


%% Andere Packages %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\usepackage{a4wide} %%Kleinere Seitenränder = mehr Text pro Zeile.
\usepackage{fancyhdr} %%Fancy Kopf- und Fußzeilen
%\usepackage{longtable} %%Für Tabellen, die eine Seite überschreiten
\usepackage{lastpage}
\usepackage[raggedright]{subfigure}
\usepackage[final]{pdfpages}
\includepdfset{pages=-,noautoscale}

\usepackage{listings}
\definecolor{bg}{rgb}{0.98,0.98,0.98}
\lstset{language=C,basicstyle=\small,keywordstyle=\color{blue}\bfseries,%
tabsize=2,backgroundcolor=\color{bg},numbers=left,%
basicstyle=\scriptsize\ttfamily,breaklines=true,breakatwhitespace=true,%
stringstyle=\color{violet}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% TODO
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 
% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Optionen / Modifikationen
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{Einstellungen}

% Formeln römisch nummerieren
\renewcommand{\theequation}{\Roman{equation}} 

% "Formel" statt "Gleichung"
\def\equationname{Formel}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% DOKUMENT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\title{Projektarbeit: High Power RGB-LED}
\date{\today}
\author{Cyril Stoller, Marcel Bärtschi}
\maketitle

%% Inhaltsverzeichnis %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents %Inhaltsverzeichnis

\vfill

\listoffigures

%\pagestyle{fancy} %%Ab hier die Kopf-/Fusszeilen: headings / fancy / ...

\newpage

\begin{abstract}
	
\begin{center}	
\textbf{Abstract}
\vspace{0.3cm}

	Um unsere Kentnisse in VHDL und im Entwerfen von elektronischen Schaltungen zu vertiefen, haben wir ein Projekt erarbeitet, in welchem wir beides gleichermassen üben können. Dabei ist das Projekt 40 Watt high power LED entstanden. 
\end{center}
	
\end{abstract}

\vspace{2cm}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                         %%
%%         Kapitel / Hauptteil des Dokumentes              %%
%%                                                         %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\section{Ziel}
\begin{quote}
Es gibt nichts Praktischeres als eine gute Theorie.

\emph{Immanuel Kant (1724 - 1804), deutscher Philosoph}
\end{quote}
Um trotzdem mal selbst Hand anzulegen, ist ein Projekt zu erarbeiten, dass einen digitalen und einen analogen Teil enthält. Der zeitliche Rahmen ist auf ein halbes Semester begrenzt. 
Der digitale Teil soll mit einem Spartan 3E Board in VHDL realisiert werden. Für den analogen Teil sind keine Vorgaben vorhanden.

\section{Einleitung}
Wir haben uns dafür entschieden, eine RGB-LED im HSV-Farbraum\footnote{Siehe \url{https://de.wikipedia.org/wiki/HSV-Farbraum}} anzusteuern.

Dazu sollen mit dem Dreh-Encoder und vier Tastern die drei Werte \emph{Hue} (Farbwert), \emph{Value} (Dunkelstufe) und \emph{Saturation} (Sättigung) verändert werden können.

\begin{figure}[ht]
	\centering
		\includegraphics[width=0.70\textwidth]{images/Blockschaltbild_grob.pdf}
	\caption{Grobes Blockschaltbild der Idee}
	\label{fig:Blockschaltbild_grob}
\end{figure}


Der jeweilige Wert ist in 256 (acht Bit) Stufen einstellbar und wird im FPGA vom HSV- in den RGB-Farbraum umgerechnet. Danach werden diese drei Werte in Form eines PWM codierten Signals auf drei Ausgangspins ausgegeben und damit die rote, grüne und blaue LED angesteuert. Auf der Hardwareseite schaltet das PWM Signal dann eine Stromquelle, an welcher die LED angeschlossen ist. Das Blockschema ist dargestellt in \autoref{fig:Blockschaltbild_grob}.

Im folgenden werden die beiden Teilprojekte \emph{Digitalteil} und \emph{Analogteil} genauer erläutert.

\section{Digitalteil}

Für den Digitalteil nutzen wir das Entwicklungsboard Spartan-3E Starterkit. Darauf benötigen wir wie schon erwähnt den Drehencoder, die vier Taster darum herum und drei I/O Pins rechts unten. Die Position der Elemente ist auf \autoref{fig:Software-Hardware} sichtbar.

\begin{figure}[ht]
	\centering
		\includegraphics[width=0.70\textwidth]{images/Software-Hardware.pdf}
	\caption{Beschreibung der Ein- und Ausgänge auf dem Digitalteil}
	\label{fig:Software-Hardware}
\end{figure}

\subsection{Grobe Datenverarbeitung}

Der VHDL Code ist ein klassischer Fall von einem Input$\rightarrow$Processing$\rightarrow$Output System (\autoref{fig:Software}). Als Eingang fungieren drei einstellbare Werte --- der Hue-Wert, der Saturation-Wert und der Value-Wert.

Der Hue-Wert wird mit dem Drehencoder schrittweise zwischen 0 und 383 verändert. Die vier Taster dienen je zu zweit ebenfalls der Einstellung je eines Wertes. Jedoch wurde hier die Entscheidung getroffen, vor dem Zählermodul noch ein "`Autorepeat"' einzufügen, da es kaum nötig sein wird, die Sättigung oder die Helligkeit in einzelnen Schritten von 0 bis 255 zu ändern.

\begin{figure}[ht]
	\centering
		\includegraphics[width=1.00\textwidth]{images/Software.pdf}
	\caption{Blockschaltbild des Digitalteils}
	\label{fig:Software}
\end{figure}

Die drei Zählermodule benötigen am Eingang jeweils einen UP- und einen DOWN-Trigger. Im Falle der Taster (\emph{Saturation} und \emph{Value} Werte) kommen diese Signale dann auf ein Autorepeat-Modul. Dieses schaut am Eingang, ob einer der beiden Triggersignale 1 ist. Wenn dies der Fall ist, fängt es nach einer gewissen Zeit ($2.6ms$) an, den jeweiligen Ausgang mit einer gewissen Frequenz zu toggeln, welcher dann den Zähler kontinuierlich erhöht oder verringern. Im Fall des Drehencoders haben wir uns entschieden, die Schritte direkt zum Zählermodul zu führen. Jedoch müssen natürlich die beiden Eingangspins des Drehencoders zuerst decodiert werden.

Nach den Zählern werden die drei Werte dann in einem Modul vom HSV in den RGB Farbraum konvertiert und anschliessend über je ein PWM Encoder Modul auf die drei Ausgangspins gesendet.

\subsection{HSV-RGB-Encoder}

Der HSV-Farbraum (Abbildung \ref{fig:HSV}) und der RGB-Farbraum (Abbildung \ref{fig:RGB}) sind verwandt und dadurch relativ einfach umrechenbar.

\begin{figure}[ht]
	\centering
		\subfigure[HSV Farbraum]{
			\includegraphics[width=0.3\textwidth]{images/HSV.png}
			\label{fig:HSV}
		}
		\subfigure[RGB Farbraum]{
			\includegraphics[width=0.3\textwidth]{images/RGB.png}
			\label{fig:RGB}
		}
		\caption{Vergleich der beiden Farbräume}
\end{figure}

Eine grafische Darstellung der Umrechnung ist in \autoref{fig:RGB-HSV} dargestellt. 
Die Formeln dazu sind in Formel \ref{formel:a}, \ref{formel:b} und \ref{formel:c} ersichtlich.

Dabei gibt es vor allem ein Problem: In VHDL kann man nicht durch 60 teilen. Darum haben wir uns entschieden, die "`Breite"' des \emph{Hue} Wertes von $360^\circ$ auf $384^\circ$ zu erhöhen. Dadurch sind die sechs Teilbereiche, die in Formel \ref{formel:c} dargestellt sind, jeweils 64 Schritte breit. Der \emph{Hue} Wert kann also durch 64 dividiert werden, was in VHDL einem Schieben nach rechts um sechs Bit gleichkommt und somit schnell und einfach zu implementieren ist.

\begin{figure}[ht]
	\centering
		\includegraphics[width=0.6\textwidth]{images/RGB-HSV.png}
	\caption{HSV-RGB Konvertierung}
	\label{fig:RGB-HSV}
\end{figure}

\begin{align}
	\label{formel:a}
	h_\mathrm{i} &:= \left \lfloor { \frac{H}{60^\circ} } \right \rfloor;\;\;\;f:= \left(\frac{H}{60^\circ} - h_\mathrm{i}\right) \\
	%
	\label{formel:b}
	p &:= V \cdot (1 - S);\quad q:= V \cdot (1 - S \cdot f );\quad t:= V \cdot \left( 1 - S \cdot (1 - f) \right) \\
	%
	\label{formel:c}
	(R,G,B) &:=
    \begin{cases}
        (V,t,p), \text{falls } h_\mathrm{i} \in \{0,6\} \\
        (q,V,p), \text{falls } h_\mathrm{i} = 1 \\
        (p,V,t), \text{falls } h_\mathrm{i} = 2 \\
        (p,q,V), \text{falls } h_\mathrm{i} = 3 \\
        (t,p,V), \text{falls } h_\mathrm{i} = 4 \\
        (V,p,q), \text{falls } h_\mathrm{i} = 5
    \end{cases}
\end{align}

Der Code ist in einem einzigen Prozess enthalten, welcher laufend die drei Eingangswerte umrechnet und auf die drei Ausgangsvektoren schreibt. Die Codestruktur ist eine simple Fallunterscheidung nach den sechs unterschiedlichen Teilbereichen im Hue-Spektrum (welches nun eben $384^\circ$ breit ist). Das Listing der wichtigsten Codeausschnitts ist in \autoref{lst:rgbencoder} sichtbar.

\begin{lstlisting}[frame=single,caption={Ausschnitt aus dem VHDL-Code \texttt{RGBEncoder.hdl}},label=lst:rgbencoder]
if SAT = "00000000" then
	R <= VAL;
	G <= VAL;
	B <= VAL;
else
	base := (("11111111" - unsigned(SAT)) * unsigned(VAL)) srl 8;
	switch := unsigned(HUE) srl 6;
	case switch(2 downto 0) is
		when "000" =>
			R <= VAL;
			led_value := (((unsigned(VAL) - base(7 downto 0)) * unsigned(HUE)) srl 6) + base(7 downto 0);
			G <= std_logic_vector(led_value(7 downto 0));
			B <= std_logic_vector(base(7 downto 0));
		
		when "001" =>
			led_value := (((unsigned(VAL) - base(7 downto 0)) * ("001000000"-(unsigned(HUE) mod "001000000"))) srl 6) + base(7 downto 0);
			R <= std_logic_vector(led_value(7 downto 0));
			G <= VAL;
			B <= std_logic_vector(base(7 downto 0));
		
		when "010" =>
			R <= std_logic_vector(base(7 downto 0));
			G <= VAL;
			led_value := (((unsigned(VAL) - base(7 downto 0)) * (unsigned(HUE) mod "001000000")) srl 6) + base(7 downto 0);
			B <= std_logic_vector(led_value(7 downto 0));
		
		when "011" =>
			R <= std_logic_vector(base(7 downto 0));
			led_value := (((unsigned(VAL) - base(7 downto 0)) * ("001000000"-(unsigned(HUE) mod "001000000"))) srl 6) + base(7 downto 0);
			G <= std_logic_vector(led_value(7 downto 0));
			B <= VAL;
		
		when "100" =>
			led_value := (((unsigned(VAL) - base(7 downto 0)) * (unsigned(HUE) mod "001000000")) srl 6) + base(7 downto 0);
			R <= std_logic_vector(led_value(7 downto 0));
			G <= std_logic_vector(base(7 downto 0));
			B <= VAL;
		
		when "101" =>
			R <= VAL;
			G <= std_logic_vector(base(7 downto 0));
			led_value := (((unsigned(VAL) - base(7 downto 0)) * ("001000000"-(unsigned(HUE) mod "001000000"))) srl 6) + base(7 downto 0);
			B <= std_logic_vector(led_value(7 downto 0));
			
		when others =>
			R <= "00000000";
			G <= "00000000";
			B <= "00000000";
	end case;
end if;
\end{lstlisting}

\begin{figure}[ht]
	\centering
		\includegraphics[width=1.00\textwidth]{images/RGBEncoder2.png}
	\caption{Testbench des RGB-HSV Encoder Moduls}
	\label{fig:RGBEncoder2}
\end{figure}

In einer Testbench wurde der \emph{Hue} Wert kontinuiertlich von 0 bis 383 inkrementiert und dabei die drei Ausgangswerte des RGB-HSV Encoders analysiert. In \autoref{fig:RGBEncoder2} ist der Signalverlauf dargestellt. Bei dieser Abbildung wurden anschliessend noch grafisch die Wertverläufe der drei Ausgangsvektoren veranschaulicht. Der Verlauf stimmt mit dem in \autoref{fig:RGB-HSV} überein.


\subsection{Inkremental-Decoder}

Der Dreh-Eecoder (\autoref{fig:rotary})auf dem Spartan 3E Board hat 20 Raster pro Umdrehung. Damit könnte der gesamte HSV Farbraum in ca. 19 Umdrehungen durchlaufen werden. Wir haben uns aber entschieden, den entsprechenden Up-Down-Counter für den \emph{Hue} Wert in Viererschritten zählen zu lassen. So decken wir den Farbraum mit ca. 5 Undrehungen ab.

Mit zwei der drei Ausgangspins können Drehereignisse inklusive der Drehrichtung erkannt werden. Uhrzeigersinn entspricht "`CW"' --- "`Clock-Wise"' und Gegenuhrzeigersinn entspricht "`CCW"' --- "`Counter-Clock-Wise"'. Der dritte Pin ist für den Taster, der im Knopf eingebaut ist, mit welchem man auch noch ein Druck-Ereigniss auslösen könnte. Diese Funktion haben wir aber bisher nicht benötigt.

\begin{figure}[ht]
	\centering
		\includegraphics[width=0.30\textwidth]{images/rotary.png}
	\caption{Drehencoder}
	\label{fig:rotary}
\end{figure}

Für das VHDL Inkremental-Decoder-Modul haben wir uns auf eine Code-Vorlage von Xilinx selbst gestützt. Die beiden Eingangssignale müssen auf ihre Phasen überprüft werden. In \autoref{fig:Rotary_signals} wird dies erklärt.

\begin{figure}[ht]
	\centering
		\includegraphics[width=1\textwidth]{images/Rotary_signals.png}
	\caption{Ausgangssignale des Dreh-Encoders}
	\label{fig:Rotary_signals}
\end{figure}

Im Code werden die beiden Eingangssignale in einem ersten Prozess jeweils zuerst gefiltert und dann dem zweiten Prozess, dem eigentlichen Phasendetektor, zugeführt. Dieser hat als Ausgangssignale einerseits einen CW Trigger (Uhrzeigersinn, im Code \texttt{up}) , einen CCW Trigger (Gegenuhrzeigersinn, im Code \texttt{down}) und ein Signal, mit welchem ein Trigger Ereignis angezeigt wird (\texttt{rotary\_event}).

\begin{lstlisting}[frame=single,caption={Ausschnitt aus dem VHDL-Code \texttt{RotaryEncoder.hdl}},label=lst:rotaryencoder]
rotary_a_in <= ROT_A;
rotary_b_in <= ROT_B;

filter: process(CLK)
begin
	if rising_edge(CLK) then
		rotary_in <= rotary_b_in & rotary_a_in;	-- beide eingänge zusammenkleben
		case rotary_in is
			when "00" => rotary_q1 <= '0';
			when "01" => rotary_q2 <= '0';
			when "10" => rotary_q2 <= '1';
			when "11" => rotary_q1 <= '1';
			when others =>
		end case;
	end if;
end process filter;

decoder: process(CLK)
begin
	if rising_edge(CLK) then
		delay_rotary_q1 <= rotary_q1;
		if rotary_q1 = '1' and delay_rotary_q1 = '0' then
			rotary_event <= '1';
			if rotary_q2 = '1' then
				DOWN <= '1';
			else
				UP <= '1';
			end if;
		else
			rotary_event <= '0';
			DOWN <= '0';
			UP <= '0';
		end if;
	end if;
end process decoder;
\end{lstlisting}

Die Testbench ist in \autoref{fig:RotaryEncoder} dargestellt.

\begin{figure}[ht]
	\centering
		\includegraphics[width=0.8\textwidth]{images/RotaryEncoder.png}
	\caption{Testbench des Moduls RotaryEncoder}
	\label{fig:RotaryEncoder}
\end{figure}


\subsection{Up-Down Counter}

Wir haben zwei unterschiedliche Up-Down Counter. Einer für den \emph{Value} und den \emph{Saturation} Wert, der in acht Bit (also 256 Schritten) zählt und \emph{nicht} überläuft und einer für den \emph{Hue} Wert, der in 384 Schritten zählt und überlaufen darf.

Im Code werden bei beiden Countern die beiden Eingangssignale \texttt{UP} und \texttt{DOWN} auf positive Flanke geprüft und bei einer Flanke der Zählerwert inkrementiert bzw. dekrementiert. Der Unterschied besteht in der Abfrage des Endwerts (also entweder 0 und 255 beim \autoref{lst:counter256} oder 0 und 383 beim \autoref{lst:counter384}).

\begin{lstlisting}[frame=single,caption={Ausschnitt aus dem VHDL-Code \texttt{Counter256.hdl}},label=lst:counter256]
process(RESET, CLK)
begin
	if RESET = '1' then
		cnt <= "00000000";
	elsif rising_edge(CLK) then 
		UP_old <= UP;
		DOWN_old <= DOWN;
		
		if (UP='1' and UP_old='0' and DOWN='0') then
			if cnt /= "11111111" then
				cnt <= cnt + 1;
			end if;
			
		elsif (DOWN='1' and DOWN_old='0' and UP='0') then  
			if cnt /= "00000000" then
				cnt <= cnt - 1;
			end if;
		end if;
	end if;
end process;

VALUE <= std_logic_vector(cnt);
\end{lstlisting}

\begin{lstlisting}[frame=single,caption={Ausschnitt aus dem VHDL-Code \texttt{Counter384.hdl}},label=lst:counter384]
process(RESET, CLK)
	variable cnt : unsigned(8 downto 0);
	constant step : integer := 4;
begin
	if RESET = '1' then
		cnt := "000000000";
	elsif rising_edge(CLK) then 
		UP_old <= UP;
		DOWN_old <= DOWN;

		if (UP='1' and UP_old='0' and DOWN='0') then
			if cnt /= ("110000000" - step) then
				cnt := cnt + step;
			else
				cnt := "000000000";
			end if;

		elsif (DOWN='1' and DOWN_old='0' and UP='0') then  
			if cnt /= "000000000" then
				cnt := cnt - step;
			else
				cnt := ("110000000" - step);
			end if;
		end if;
	end if;
	VALUE <= std_logic_vector(cnt);
end process;
\end{lstlisting}

\subsection{PWM-Encoder}

Der PWM Encoder wurde ebenfalls als Zähler implementiert, der das Ausgangssignal einschaltet, von 0 bis 255 zählt und bei einem gewissen Zählerwert wieder ausschaltet.

Die einzige Entscheidung, die wir treffen mussten, war die Taktfrequenz des PWM-Zählers. Diese darf nicht zu hoch sein, da die Schaltverluste am FET dann recht hoch werden. Andererseits wird bei zu tiefer Schaltfrequenz ein Flackern bei der LED sichtbar werden.

\begin{lstlisting}[frame=single,caption={Ausschnitt aus dem VHDL-Code \texttt{PWMEncoder.hdl} (PWM Code)},label=lst:pwmencoder]
process(CLK, RESET)
	variable PWM_period : unsigned(7 downto 0);
	variable clock_divider : unsigned(7 downto 0);
begin
	if RESET = '1' then
		clock_divider := "00000000";
		PWM_period := "00000000";
	elsif rising_edge(CLK) then
		clock_divider := unsigned(clock_divider) + 1;
		
		if clock_divider = "00000000" then -- bei überlauf: PWM periodenzähler erhöhen
			PWM_period := PWM_period + 1;
			
			if PWM_period = "11111111" then	-- nur bis 2^n - 2 gehen: weil es n möglichkeiten (statt n-1) gibt
				PWM_period := "00000000";
			end if;
			
			if PWM_period < log_table(to_integer(unsigned(VALUE))) then
				PWM <= '1';
			else
				PWM <= '0';
			end if;
		end if;
	end if;
end process;
\end{lstlisting}

Wir haben uns dafür entschieden, eine möglichst tiefe Frequenz gerade noch ohne sichtbares Flackern zu wählen. Wir teilen die Systemclock Frequenz von 50MHz mit einem 8 Bit Zähler auf 195kHz herunter. Dann ist ja der PWM-Zähler selber 8 Bit gross, das heisst, eine PWM-Periode ist dann $20ns \cdot 256 \cdot 256 = 1.31ms$ lang und hat somit eine Frequenz von ca. 760Hz.

Danach haben wir noch eine Look-Up-Table eingefügt, welche den eigentlichen Ausgangswert logarithmiert (siehe dazu \url{http://www.mikrocontroller.net/articles/LED-Fading} und \autoref{fig:Logarithmiktabelle}).

\begin{lstlisting}[frame=single,caption={Ausschnitt aus dem VHDL-Code \texttt{PWMEncoder.hdl} (Look-Up-Table)},label=lst:pwmencoder2]
type nums is array(0 to 255) of integer;
constant log_table : nums := (
	0      => 0,
	1      => 0,
	2      => 0,
	3      => 0,
	
...

 252    => 241,
 253    => 246,
 254    => 250,
 255    => 255
 );
\end{lstlisting}

Der Code für diese Tabelle ist in \autoref{lst:pwmencoder2} angegeben. Man kann dann die Tabelle wie einen Vektor benutzen und den gewünschten Wert mit einem Index anwählen: \texttt{log\_table(to\_integer(unsigned(VALUE)))}.

\begin{figure}[ht]
	\centering
		\includegraphics{images/Logarithmiktabelle.png}
	\caption{Logarithmik Umrechnung}
	\label{fig:Logarithmiktabelle}
\end{figure}

\section{Analogteil}
Im analogen Teil des Projekts ging es darum, eine High Power RGB LED mit einer möglichst effizienten Schaltung anzusteuern.

\subsection{Schema}
Das Schema für den Analogteil beinhaltet im Wesentlichen die drei Stromquellen für die drei Farben der LED. Es ist in \autoref{fig:Schema} dargestellt.

\begin{figure}[ht]
	\centering
		\includegraphics[width=1\textwidth]{images/schema.pdf}
	\caption{Schema}
	\label{fig:Schema}
\end{figure}

\subsection{Bauteilspezifikation}

\subsubsection{RGB-LED}
Bei der Evaluation der LED war die Leistung unser Hauptkriterium. Wir haben uns schlussendlich für das Modell LZC-00MC40 von LedEngin Inc entschieden (\autoref{fig:RGB-LED}). Das Datenblatt ist im Anhang zu finden.

\begin{figure}[ht]
	\centering
		\includegraphics[width=0.50\textwidth]{images/RGB-LED.png}
	\caption{RGB LED}
	\label{fig:RGB-LED}
\end{figure}

Die LED hat eine Gesamtleistung von $40W$ und je vier LEDs für jede der drei Farben rot, grün und blau. Die Farbgruppen sind jeweils seriell geschaltet und haben je einen maximalen Durchflussstrom von $1A$. Wir haben uns jedoch auf einen maximalen Strom von $800mA$ festgelegt.

Die Vorwärtsspannungen variieren je nach Durchflussstrom. Für einen Strom von je $800mA$ sind die ungefähren Werte: $V_{F-Rot} \approx 9.5V$, $V_{F-Gruen} \approx 14V$ und $V_{F-Blau} \approx 16.5V$.

\subsubsection{Stromquelle}
Als Stromquelle haben wir uns für eine Konstantstromquelle von ON Semiconductor entschieden - den CAT4101 (\autoref{fig:Stromregler}). Der Strom ist mittels einer Widerstandsbeschaltung eines Pins bis zu $1A$ einstellbar. Um diesen Strom einzustellen, mussten wir einen $680 \Omega$-Widerstand beschalten. Der Stromregler besitzt ausserdem einen PWM-Eingang der es erlaubt, die Stromquelle mit einem hochfrequenzen PWM Signal zu steuern.

\begin{figure}[ht]
	\centering
		\includegraphics[width=0.40\textwidth]{images/Stromregler.png}
	\caption{Stromregler}
	\label{fig:Stromregler}
\end{figure}

Für die interne Logik wird eine Speisespannung von $5V$ benötigt. Die Dropout Spannung (Spannung die über dem Regler verloren geht) beträgt $0.5V$. Mit diesen Angaben haben wir die Speisespannungen für die drei RGB LED Anschlüsse folgendermassen festgelegt: Die erwartete Vorwärtsspannung der entsprechenden Farbe plus mindestens $0.5V$. Dies ergab folgende Speisespannungen (im Schema bei \autoref{fig:Schema} auch so bezeichnet): $V_{Rot} = 10.5V$, $V_{Gruen} = 17.5$ und $V_{Blau} = 14.5V$.

\subsection{Kühlkörperdimensionierung}
Die beiden Bauteile, welche betroffen sind, sind der Stromregler und die RGB LED. Der Stromregler benötigt keine spezielle Kühlung. Dies hat sich auch nach mehreren Testdurchgängen bestätigt.

\begin{figure}[ht]
	\centering
		\includegraphics[width=1\textwidth]{images/Rth_schema.pdf}
	\caption{Wärmeersatzschaltbild der RGB LED}
	\label{fig:Wärmeersatzschaltbild}
\end{figure}

Die RGB LED jedoch schon. Im Datenblatt finden sich für die verschiedenen Wärmewiderstände (Wärmeersatzschaltbild: \autoref{fig:Wärmeersatzschaltbild}, Aufbau grafisch: \autoref{fig:AufbauLED}) die folgenden Werte: $R_{\vartheta JC} = 0.7K/W$ und $R_{\vartheta CB} = 0.8K/W$. Wir haben zwischen der RGB LED und dem Kühlkörper noch eine wärmeleitende Klebefolie angebracht und schätzen für diese einen Wärmewiderstand von $R_{\vartheta BK} = 0.5K/W$.

\begin{figure}[ht]
	\centering
		\includegraphics[width=0.60\textwidth]{images/AufbauLED.pdf}
	\caption{Kühlkörperaufbau}
	\label{fig:AufbauLED}
\end{figure}


Nun wollen wir wissen, wie tief der Wärmewiderstand des Kühlkörpers an die Umgebung sein muss, um bei einer Umgebungstemperatur von $20^\circ C$ eine Halbleitertemperatur von höchstens $125^\circ C$ zu erreichen. Wir rechnen dabei mit der maximalen Leistung der RGB LED von $40W$.

\begin{equation}
\begin{split}
		R_{KAmax} &= \frac{\vartheta _{Junction} - \vartheta _{Ambient}}{P_V}-(R_{\vartheta JC}+ R_{\vartheta CB}+ R_{\vartheta BK})\\
		&= \frac{150^\circ C - 25^\circ C}{40W}-(0.7K/W + 0.8K/W + 0.5K/W) = 1.125K/W
\end{split}
\end{equation}

Bei Farnell haben wir einen Kühlkörper gefunden mit einem Wärmewiderstand von $0.7K/W$, welcher nur $60x60mm$ gross ist (\autoref{fig:Kuehlkoerper}).

\begin{figure}[ht]
	\centering
		\includegraphics[width=0.40\textwidth]{images/Kuehlkoerper.png}
	\caption{Kühlkörper für RGB LED}
	\label{fig:Kuehlkoerper}
\end{figure}



\subsection{Hardwareaufbau}

\section{Inbetriebnahme}

\section{Schlussfolgerung}


\vfill
\begin{tabular}{rr}
	\\
	\\
	\\
	\\
	\toprule
	\scriptsize{Datum und Unterschrift}	\hspace{3cm}	&	\textsc{Marcel Bärtschi}	\\
	\\
	\\
	\\
	\\
	\toprule
	\scriptsize{Datum und Unterschrift}	\hspace{3cm}	&	\textsc{Cyril Stoller}
\end{tabular}


% Der Anhang kommt auf eine neue Zeile
\newpage
% Offizielle "A Anhang" Aufzählungsvariante
\appendix
% Nur im Inhaltsverzeichnis hinzufügen (mit richtiger Seite, da vorher "\newpage"), aber kein Text
\addcontentsline{toc}{section}{Anhang}

% Quellenverzeichnis
%\addcontentsline{toc}{section}{Quellenverzeichnis}
\section{Quellenverzeichnis}
\renewcommand\refname{}

\vspace{-1cm}

\bibliographystyle{amsplain}
\bibliography{Bildquellen}

\end{document}
